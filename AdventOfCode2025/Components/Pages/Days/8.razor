@namespace Nixill.AdventOfCode.Year2025
@rendermode InteractiveServer

@page "/days/8"
@using BlazorBootstrap
@using System.Text.RegularExpressions
@using Nixill.Collections
@using Nixill.Utils
@using Nixill.Utils.Extensions
@using Nixill.Utils.Trials
@using Nixill.Utils.ValueExtensions

<h1>Day 8: Playground</h1>

<p>Enter junction box node coordinates here:</p>

<p>
  <form @onsubmit="() => ParseInput()" @formname="day-8-input">
    <TextAreaInput style="font-family: monospace;" @bind-Value="@TextValue" />
    <Button @onclick="() => ParseInput()" Color="ButtonColor.Success">Submit</Button>
  </form>
</p>

@if (Errors.Length > 0)
{
  <p style="color:#c33;">
    The following lines could not be parsed into coordinates: @Errors.Select(r => r.Index).StringJoin(", ");
  </p>
}

<p>
  You can also select a file to load all of its nodes at once:<br />
  @foreach (var file in Directory.EnumerateFiles(Directory.GetParent(Directory.GetCurrentDirectory())?.FullName +
    "/AoC2025Data/day8"))
  {
    ButtonColor color;
    if (Path.GetFileName(file) == "input.txt") color = ButtonColor.Primary;
    else color = ButtonColor.Secondary;
    <Button @onclick="() => ParseFile(file)" Color="color">@Path.GetFileName(file)</Button>
  }
</p>

<p>
  And lastly, you can reset the nodes by clicking <Button @onclick="() => ResetEverything()"
    Color="ButtonColor.Danger">here</Button>.
</p>

<p>
  There are <strong>@Nodes.Count</strong> nodes loaded, which can form a network of
  <strong>@Connections.Length</strong> connections. Please select below which connection you would
  like to view:<br/>
  <RangeInput TValue="int" @bind-Value="ViewAtConnection" @bind-Max="ConnectionCount" Min="0" />
  <NumberInput TValue="int" @bind-Value="ViewAtConnection" EnableMinMax="true" @bind-Max="ConnectionCount" Min="0"
    style="max-width: 100px;" /><br/>
  You can also jump to the <Button @onclick="() => JumpToJoin(false)" Disabled="@(ViewAtConnection <= 0)">Previous</Button>
  or <Button @onclick="() => JumpToJoin(true)" Disabled="@(ViewAtConnection >= ConnectionCount)">Next</Button> connection.
</p>

<p>
  After <strong>@ViewAtConnection</strong> connection(s), there are <strong>@GetNetworksAt(ViewAtConnection).Count()</strong>
  networks. From largest to smallest, they are:

  <ul>
    @foreach (NetworkNode network in GetNetworksAt(ViewAtConnection))
    {
      <li style="color: #@network.Color">
        <b>@network.ID</b>: @network.History.FloorEntry(ViewAtConnection).Value.Size nodes,
        @network.ConnectionCount.FloorEntry(ViewAtConnection).Value connections
      </li>
    }
  </ul>
</p>

@code
{
  string TextValue = "";
  FailedTrialResult<IntVector3>[] Errors = [];

  List<NetworkNode> Nodes = [];
  NodeConnection[] Connections = [];

  int ViewAtConnection = 0;
  int ConnectionCount = 0;

  AVLTreeSet<int> NetworkJoins = [0];

  private void ParseInput()
  {
    var trials = TextValue
      .Split(["\r\n", "\r", "\n"], StringSplitOptions.RemoveEmptyEntries)
      .TrySelectSplit(s => IntVector3.Parse(s));

    ViewAtConnection = 0;
    ConnectionCount = 0;
    
    Errors = [.. trials.Failures];

    Nodes = [.. trials.Successes.Select((itm, ind) => new NetworkNode(ind, itm.Result))];

    // Build the list of connections next
    Connections = Nodes.Combinations(2)
      .Select(e => e.Double())
      .Select(t => new NodeConnection(First: t.First, Second: t.Second,
        Distance: t.First.Position.SquaredDistanceTo(t.Second.Position)))
      .OrderBy(t => t.Distance).ToArray();
    
    ConnectionCount = Connections.Length;
    
    // Now iterate the list of connections
    foreach ((int i, (NetworkNode firstNode, NetworkNode secondNode, long squaredDistance)) in Connections.Index())
    {
      int c = i + 1;
      NetworkNode firstNetwork = GetNetwork(firstNode.ID, c);
      NetworkNode secondNetwork = GetNetwork(secondNode.ID, c);

      if (firstNetwork.ID == secondNetwork.ID)
      {
        firstNetwork.ConnectionCount.Add(c, firstNetwork.ConnectionCount.FloorEntry(i).Value + 1);
      }
      else
      {
        if (firstNetwork.ID > secondNetwork.ID) (firstNetwork, secondNetwork) = (secondNetwork, firstNetwork);
        firstNetwork.NodesInNetwork.UnionWith(secondNetwork.NodesInNetwork);
        firstNetwork.ConnectionCount.Add(c,
          firstNetwork.ConnectionCount.FloorEntry(i).Value + secondNetwork.ConnectionCount.FloorEntry(i).Value + 1);
        firstNetwork.History.Add(c, new(firstNetwork.NodesInNetwork.Count, secondNetwork.ID));
        foreach (int node in secondNetwork.NodesInNetwork)
        {
          Nodes[node].History.Add(c, new(0, firstNetwork.ID));
        }

        NetworkJoins.Add(c);
      }
    }

    NetworkJoins.Add(ConnectionCount);
  }

  NetworkNode GetNetwork(int ofNode, int atPoint)
  {
    NetworkNode node = Nodes[ofNode];
    var floorValue = node.History.FloorEntry(atPoint).Value;
    while (floorValue.Size == 0)
    {
      node = Nodes[floorValue.JoinedWith];
      floorValue = node.History.FloorEntry(atPoint).Value;
    }

    return node;
  }

  IEnumerable<NetworkNode> GetNetworksAt(int point)
    => Nodes.Where(n => n.History.FloorEntry(point).Value.Size > 0)
      .OrderByDescending(n => n.History.FloorEntry(point).Value.Size);
  
  void JumpToJoin(bool forwards)
  {
    if (forwards) ViewAtConnection = NetworkJoins.Higher(ViewAtConnection);
    else ViewAtConnection = NetworkJoins.Lower(ViewAtConnection);
  }

  void ParseFile(string fileName)
  {
    TextValue = File.ReadAllText(fileName);
    ParseInput();
  }

  void ResetEverything()
  {
    TextValue = "";
    Errors = [];
    Nodes = [];
    ViewAtConnection = 0;
    ConnectionCount = 0;
  }

  public readonly record struct IntVector3(int X, int Y, int Z)
  {
    public static IntVector3 Parse(string input)
      => input.Split(",").Select(s => int.Parse(s)).Triple()
        .Mutate(t => new IntVector3(t.First, t.Second, t.Third));

    public long SquaredDistanceTo(IntVector3 other)
      => ((long)X - (long)other.X) * ((long)X - (long)other.X)
        + ((long)Y - (long)other.Y) * ((long)Y - (long)other.Y)
        + ((long)Z - (long)other.Z) * ((long)Z - (long)other.Z);
  }

  public readonly record struct NetworkNode(int ID, IntVector3 Position)
  {
    public readonly AVLTreeDictionary<int, NetworkRecord> History = [new(0, new(1, ID))];
    public readonly AVLTreeDictionary<int, int> ConnectionCount = [new(0, 0)];
    public readonly HashSet<int> NodesInNetwork = [ID];
    public readonly string Color = Functions.RandomColor();
  }

  public readonly record struct NetworkRecord(int Size, int JoinedWith);

  public readonly record struct NodeConnection(NetworkNode First, NetworkNode Second, long Distance);
}