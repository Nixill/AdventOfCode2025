@namespace Nixill.AdventOfCode.Year2025
@rendermode InteractiveServer

@page "/days/2"
@using BlazorBootstrap
@using System.Text.RegularExpressions
@using Nixill.Collections
@using Nixill.Utils
@using Nixill.Utils.Extensions

<h1>Day 2: Gift Shop</h1>

<p>Welcome to the gift shop! Please insert your product IDs below:</p>

<p>
  <TextInput @bind-Value="@TextValue" /> <Button @onclick="() => AcceptInput()"
    Color="ButtonColor.Success">Submit</Button>
</p>

<p>
  You can also select a file to load all of its product IDs at once:<br />
  @foreach (var file in Directory.EnumerateFiles(Directory.GetParent(Directory.GetCurrentDirectory())?.FullName +
    "/AoC2025Data/day2"))
  {
    ButtonColor color;
    if (Path.GetFileName(file) == "input.txt") color = ButtonColor.Primary;
    else color = ButtonColor.Secondary;
    <Button @onclick="() => ParseFile(file)" Color="color">@Path.GetFileName(file)</Button>
  }
</p>

<p>
  And lastly, you can reset the loaded product IDs by clicking <Button @onclick="() => ResetEverything()"
    Color="ButtonColor.Danger">here</Button>.
</p>

<h2>Invalid IDs</h2>

<p>
  There is one confirmed way of identifying invalid product identifiers, which is that any product ID composed of the
  same digits twice is invalid. There is a second suspected method, which is that any product ID composed of the same
  digits any number of times more than once is invalid. Both methods are shown below:
</p>

<ul>
  <li>Only repeated once: <b>@InvalidIDs.Count</b> IDs, totaling <b>@InvalidIDs.Sum()</b></li>
  <li>Any number of repeats: <b>@ExpandedInvalidIDs.Count</b> IDs, totaling <b>@ExpandedInvalidIDs.Sum()</b></li>
</ul>

<p>For more details, see the lists below:</p>

<h2>Only repeated once:</h2>

<ul>
  @foreach (long l in InvalidIDs)
  {
    <li>@l</li>
  }
</ul>

<h2>Any number of repeats:</h2>

<ul>
  @foreach (long l in ExpandedInvalidIDs)
  {
    <li>@l</li>
  }
</ul>

@* <Accordion>
  <AccordionItem>
    <TitleTemplate>
      Only repeated twice: @InvalidIDs.Count (Sum: @InvalidIDs.Sum())
    </TitleTemplate>
    <Content>
      <ul>
        @foreach (long l in InvalidIDs)
        {
          <li>@l</li>
        }
      </ul>
    </Content>
  </AccordionItem>
  <AccordionItem>
    <TitleTemplate>
      Any number of repeats: @ExpandedInvalidIDs.Count (Sum: @ExpandedInvalidIDs.Sum())
    </TitleTemplate>
    <Content>
      <ul>
        @foreach (long l in ExpandedInvalidIDs)
        {
          <li>@l</li>
        }
      </ul>
    </Content>
  </AccordionItem>
</Accordion> *@

@code
{
  string TextValue = "";
  HashSet<long> InvalidIDs = [];
  HashSet<long> ExpandedInvalidIDs = [];

  private void AcceptInput()
  {
    ParseLine(TextValue);
    TextValue = "";
  }

  void ParseFile(string fileName)
  {
    foreach (string line in File.ReadAllLines(fileName))
    {
      ParseLine(line);
    }
  }

  void ResetEverything()
  {
    InvalidIDs = [];
    ExpandedInvalidIDs = [];
  }

  static Regex RangeRegex = new(@"(\d+)-(\d+),?");

  void ParseLine(string line)
  {
    MatchCollection matches = RangeRegex.Matches(line);

    foreach (Match match in matches)
    {
      ParseRange(match.Groups[1].Value, match.Groups[2].Value);
    }
  }

  void ParseRange(string low, string high)
  {
    // probably not but just in case :3
    if (high.Length < 2) return;
    if (low.Length < 2) low = "10";

    if (low.Length == high.Length)
    {
      ParseSubrange(low, high);
    }
    else
    {
      ParseSubrange(low, new string('9', low.Length));
      foreach (int i in Sequence.RangeBetween(low.Length, high.Length, false))
        ParseSubrange("1" + new string('0', i - 1), new string('9', i));
      ParseSubrange("1" + new string('0', high.Length - 1), high);
    }
  }

  void ParseSubrange(string low, string high)
  {
    int len = low.Length;

    foreach (int i in Enumerable.Range(2, len - 1))
    {
      if (len % i == 0)
      {
        HashSet<long> check = (i == 2) ? InvalidIDs : ExpandedInvalidIDs;
        string lowOpen = low[0..(len / i)];
        string highOpen = high[0..(len / i)];

        if (lowOpen == highOpen)
        {
          string rept = lowOpen.Repeat(i).FormString();
          if (low.CompareTo(rept) <= 0 && high.CompareTo(rept) >= 0) check.Add(long.Parse(rept));
        }
        else
        {
          string lowRept = lowOpen.Repeat(i).FormString();
          if (low.CompareTo(lowRept) <= 0) check.Add(long.Parse(lowRept));

          long factor = long.Parse(new string(['1', .. (new string('0', len / i - 1) + "1").Repeat(i - 1)]));

          foreach (int j in Sequence.RangeBetween(int.Parse(lowOpen), int.Parse(highOpen), false))
          {
            check.Add(j * factor);
          }

          string highRept = highOpen.Repeat(i).FormString();
          if (high.CompareTo(highRept) >= 0) check.Add(long.Parse(highRept));
        }
      }
    }

    ExpandedInvalidIDs.UnionWith(InvalidIDs);
  }
}