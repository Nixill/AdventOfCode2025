@namespace Nixill.AdventOfCode.Year2025
@rendermode InteractiveServer

@page "/days/9"
@using BlazorBootstrap
@using System.Text.RegularExpressions
@using Nixill.AdventOfCode.Year2025.Modules
@using Nixill.Collections
@using Nixill.Objects
@using Nixill.Utils
@using Nixill.Utils.Extensions
@using System.Text

<h1>Day 9: Template</h1>

<p>Enter red tile coordinates here!</p>

<p>
  <form @onsubmit="() => ParseInput()" @formname="day-9-input">
    <TextAreaInput style="font-family: monospace;" @bind-Value="@TextValue" />
    <Button @onclick="() => ParseInput()" Color="ButtonColor.Success">Submit</Button>
  </form>
</p>

<p>
  You can also select a file to load all of its coordinates at once:<br />
  @foreach (var file in Directory.EnumerateFiles(Directory.GetParent(Directory.GetCurrentDirectory())?.FullName +
    "/AoC2025Data/day9"))
  {
    ButtonColor color;
    if (Path.GetFileName(file) == "input.txt") color = ButtonColor.Primary;
    else color = ButtonColor.Secondary;
    <Button @onclick="() => ParseFile(file)" Color="color">@Path.GetFileName(file)</Button>
  }
</p>

<p>
  And lastly, you can reset the coordinates by clicking <Button @onclick="() => ResetEverything()"
    Color="ButtonColor.Danger">here</Button>.
</p>

@if (Initialized)
{
  <p>
    The largest rectangular rug possible between red tiles in this room covers an area of
    <strong>@((LargestRug.Second.X - LargestRug.First.X + 1) * (LargestRug.Second.Y - LargestRug.First.Y + 1))</strong> tiles,
    going from <strong>(@LargestRug.First)</strong> to <strong>(@LargestRug.Second)</strong>.
  </p>

  <p>
    Additionally, the rug formed by all red tiles in the room covers an area of
    <strong>@(Field?.GetArea() ?? 0)</strong> tiles.
  </p>

  <p>
    The map of the room can be viewed below:
  </p>

  <svg width="1100" height="1100" viewBox="-50 -50 1100 1100">
    <rect x="@GetCoordinate(LargestRug.First.X)" y="@GetCoordinate(LargestRug.First.Y)"
      width="@GetCoordinateLength(LargestRug.Second.X - LargestRug.First.X + 1)"
      height="@GetCoordinateLength(LargestRug.Second.Y - LargestRug.First.Y + 1)" style="fill: #33c" />
    <g>
      @foreach (IntVector2 cPair in Coordinates)
      {
        string style = (cPair == LargestRug.First || cPair == LargestRug.Second ||
          cPair == (LargestRug.First.X, LargestRug.Second.Y) ||
          cPair == (LargestRug.Second.X, LargestRug.First.Y))
          ? "fill: #c33; stroke-color: #000; stroke-width: 2px;" : "fill: #000; stroke: none";
        <circle cx="@GetCoordinate(cPair.X + 0.5)" cy="@GetCoordinate(cPair.Y + 0.5)" r="3" style="@style" />
      }
    </g>
    <path d="@PathData" style="fill: #3c37; stroke: #3c3; stroke-width: 2px;" />
  </svg>
}

@code
{
  string TextValue = "";
  List<IntVector2> Coordinates = [];
  int LowCoordinate = int.MaxValue;
  int HighCoordinate = int.MinValue;
  (IntVector2 First, IntVector2 Second) LargestRug = default;
  string PathData = "";
  bool Initialized = false;
  D9Field? Field = null;

  private void ParseInput()
  {
    Coordinates = [];
    LowCoordinate = int.MaxValue;
    HighCoordinate = int.MinValue;
    LargestRug = default;
    PathData = "";
    Field = null;
    Initialized = false;

    StringBuilder pathDataBuilder = new();

    foreach (string line in TextValue.SplitLines())
    {
      if (IntVector2.TryParse(line, out IntVector2 value))
      {
        Coordinates.Add(value);
        LowCoordinate = int.Min(int.Min(value.X, value.Y), LowCoordinate);
        HighCoordinate = int.Max(int.Max(value.X, value.Y), HighCoordinate);
      }
    }

    if (Coordinates.Count == 0) return;

    HighCoordinate += 1;

    LargestRug = Coordinates.Combinations(2)
      .Select(e => e.Double())
      .MaxBy(t => (long.Abs(t.First.X - t.Second.X) + 1) * (long.Abs(t.First.Y - t.Second.Y) + 1));
    
    if (LargestRug.First.X > LargestRug.Second.X) LargestRug = (LargestRug.Second, LargestRug.First);
    if (LargestRug.First.Y > LargestRug.Second.Y)
      LargestRug = ((LargestRug.First.X, LargestRug.Second.Y), (LargestRug.Second.X, LargestRug.First.Y));

    pathDataBuilder.Append($"M {GetCoordinate(Coordinates[0].X + 0.5)} {GetCoordinate(Coordinates[0].Y + 0.5)} ");

    foreach (IntVector2 cPair in Coordinates.Skip(1))
    {
      pathDataBuilder.Append($"L {GetCoordinate(cPair.X + 0.5)} {GetCoordinate(cPair.Y + 0.5)} ");
    }

    pathDataBuilder.Append("Z");

    PathData = pathDataBuilder.ToString();

    Field = new D9Field([.. Coordinates]);
    
    Initialized = true;
  }

  public double GetCoordinate(double from)
    => NumberUtils.ReLerp(from, LowCoordinate, HighCoordinate, 0, 1000);
  
  public double GetCoordinateLength(double fromLength)
    => GetCoordinate(fromLength + LowCoordinate);

  void ParseFile(string fileName)
  {
    TextValue = File.ReadAllText(fileName);
    ParseInput();
  }

  void ResetEverything()
  {
    TextValue = "";
    Coordinates = [];
    LowCoordinate = int.MaxValue;
    HighCoordinate = int.MinValue;
    LargestRug = default;
    PathData = "";
    Initialized = false;
    Field = null;
  }

  public class D9Field
  {
    AVLTreeDictionary<long, AVLTreeSet<long>> Coordinates = new();
    DictionaryGenerator<long, AVLTreeSet<long>> GenCoords;
    long Perimeter = 0;

    public D9Field(IntVector2[] coordinates)
    {
      GenCoords = new(Coordinates, new EmptyConstructorGenerator<long, AVLTreeSet<long>>());

      int x = coordinates[^1].X;
      int y = coordinates[^1].Y;

      foreach ((int cx, int cy) in coordinates.Select(c => c.ToXY()))
      {
        GenCoords[x].Add(y);
        Perimeter += int.Abs(x - cx) + int.Abs(y - cy);
        x = cx;
        y = cy;
      }
    }

    public long GetArea()
    {
      long area = 0;
      long currentArea = 0;
      AVLTreeSet<long> currentBounds = new();

      long lastX = Coordinates.LowestKey();

      foreach ((long x, AVLTreeSet<long> lineX) in Coordinates)
      {
        area += currentArea * (x - lastX);

        foreach (long y in lineX)
        {
          if (currentBounds.Contains(y)) currentBounds.Remove(y);
          else currentBounds.Add(y);
        }

        currentArea = 0;
        foreach (long[] twoY in currentBounds.Chunk(2))
        {
          currentArea += twoY[1] - twoY[0];
        }

        lastX = x;
      }

      return area + Perimeter / 2 + 1;
    }
  }
}
